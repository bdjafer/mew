-- =============================================================================
-- ONTOLOGY: SelfDescribingKB
-- LEVEL: C (Advanced)
-- PURPOSE: Knowledge base that can reason about its own structure and content
-- =============================================================================

ontology SelfDescribingKB : Layer0 {

  -- ===========================================================================
  -- NODE TYPES
  -- ===========================================================================

  -- Core knowledge types
  node Concept {
    name: String [required],
    definition: String?,
    abstraction_level: Int = 0        -- 0 = concrete, higher = more abstract
  }

  node Instance {
    label: String [required],
    description: String?
  }

  node Proposition {
    statement: String [required],
    truth_value: Bool?,               -- null = unknown
    confidence: Float = 0.5,
    asserted_at: Timestamp?,
    source: String?
  }

  node Context {
    name: String [required],
    description: String?,
    valid_from: Timestamp?,
    valid_until: Timestamp?
  }

  -- Meta-knowledge types
  node KnowledgeGap {
    description: String [required],
    importance: Float = 0.5,
    identified_at: Timestamp?
  }

  node Inference {
    inference_type: String [required], -- "deduction", "induction", "abduction"
    confidence: Float = 0.5,
    performed_at: Timestamp?
  }

  node Contradiction {
    description: String?,
    detected_at: Timestamp?,
    resolved: Bool = false,
    resolution: String?
  }

  -- Reference to ontology structure itself
  node OntologyAnnotation {
    target_type: String [required],   -- name of _NodeType or _EdgeType
    annotation: String [required],
    annotation_type: String?          -- "usage", "caveat", "example"
  }

  -- ===========================================================================
  -- EDGE TYPES
  -- ===========================================================================

  -- Basic knowledge relations
  edge is_a(instance: Instance | Concept, concept: Concept) {}

  edge part_of(part: Instance | Concept, whole: Instance | Concept) {}

  edge related_to(from: Concept, to: Concept) {
    relation_type: String?,
    strength: Float = 1.0,
    symmetric: Bool = false
  }

  edge instance_of(instance: Instance, concept: Concept) {}

  -- Proposition relations
  edge asserts(prop: Proposition, about: Instance | Concept) {}

  edge implies(antecedent: Proposition, consequent: Proposition) {
    strength: Float = 1.0
  }

  edge contradicts_prop(p1: Proposition, p2: Proposition) {}

  edge in_context(prop: Proposition, context: Context) {}

  -- Higher-order: confidence about any edge
  edge edge_confidence(
    about: edge<any>,
    level: Float
  ) {
    source: String?,
    assessed_at: Timestamp?
  }

  -- Higher-order: provenance of any edge
  edge provenance(
    about: edge<any>,
    source: String,
    timestamp: Timestamp
  ) {
    method: String?                   -- "observation", "inference", "import"
  }

  -- Higher-order: derived from (inference chain)
  edge derived_from(
    derived: edge<any>,
    source: edge<any>
  ) {
    derivation_rule: String?
  }

  -- Meta-knowledge relations
  edge identifies_gap(prop: Proposition, gap: KnowledgeGap) {
    -- proposition reveals a gap in knowledge
  }

  edge produced_by(result: edge<any>, inference: Inference) {}

  edge involves_contradiction(
    contradiction: Contradiction,
    edge1: edge<any>,
    edge2: edge<any>
  ) {}

  edge annotates_type(
    annotation: OntologyAnnotation,
    target: _NodeType | _EdgeType
  ) {}

  -- Self-reference: knowledge about this ontology
  edge describes_self(
    concept: Concept,
    ontology: _Ontology
  ) {
    -- concept is about this ontology itself
  }

  -- ===========================================================================
  -- CONSTRAINTS
  -- ===========================================================================

  -- Confidence values in valid range
  constraint confidence_range:
    p: Proposition
    => p.confidence >= 0.0 AND p.confidence <= 1.0

  constraint edge_confidence_range:
    e: edge<any>, level: Float, edge_confidence(e, level)
    => level >= 0.0 AND level <= 1.0

  -- Contradiction involves two different edges
  constraint contradiction_different_edges:
    c: Contradiction, e1: edge<any>, e2: edge<any>,
    involves_contradiction(c, e1, e2)
    => e1.id != e2.id

  -- No circular is_a
  constraint no_is_a_self:
    c: Concept, is_a(c, c)
    => false

  constraint no_is_a_cycle_2:
    c1: Concept, c2: Concept,
    is_a(c1, c2), is_a(c2, c1)
    => false

  -- Contradicting propositions can't both be true
  constraint no_true_contradiction:
    p1: Proposition, p2: Proposition,
    contradicts_prop(p1, p2)
    => NOT (p1.truth_value = true AND p2.truth_value = true)

  -- ===========================================================================
  -- RULES
  -- ===========================================================================

  -- Detect contradictions between propositions
  rule detect_contradiction [priority: 10]:
    p1: Proposition, p2: Proposition,
    contradicts_prop(p1, p2)
    WHERE p1.truth_value = true AND p2.truth_value = true
      AND NOT EXISTS(
        c: Contradiction,
        involves_contradiction(c, contradicts_prop(p1, p2), _)
      )
    =>
    CREATE c: Contradiction {
      description = "Contradicting true propositions detected",
      detected_at = now(),
      resolved = false
    }
    -- Note: The constraint should prevent this, but rule catches edge cases

  -- Propagate truth through implication
  rule modus_ponens [priority: 8]:
    p1: Proposition, p2: Proposition,
    implies(p1, p2) AS imp
    WHERE p1.truth_value = true 
      AND p2.truth_value = null
      AND imp.strength >= 0.8
    =>
    SET p2.truth_value = true,
    SET p2.confidence = p1.confidence * imp.strength,
    CREATE i: Inference {
      inference_type = "deduction",
      confidence = p1.confidence * imp.strength,
      performed_at = now()
    },
    CREATE derived_from(asserts(p2, _), asserts(p1, _)) {
      derivation_rule = "modus_ponens"
    }

  -- Identify knowledge gaps from low confidence
  rule low_confidence_gap [priority: 3]:
    p: Proposition, c: Concept,
    asserts(p, c)
    WHERE p.confidence < 0.3 
      AND p.truth_value = null
      AND NOT EXISTS(g: KnowledgeGap, identifies_gap(p, g))
    =>
    CREATE g: KnowledgeGap {
      description = "Low confidence proposition: " + p.statement,
      importance = 1.0 - p.confidence,
      identified_at = now()
    },
    CREATE identifies_gap(p, g)

  -- Transitive is_a
  rule transitive_is_a [priority: 5]:
    c1: Concept, c2: Concept, c3: Concept,
    is_a(c1, c2), is_a(c2, c3)
    WHERE NOT EXISTS(is_a(c1, c3))
    =>
    CREATE is_a(c1, c3)

  -- Add provenance to new edges (catch-all)
  rule auto_provenance [priority: 1]:
    e: edge<any>
    WHERE NOT EXISTS(provenance(e, _, _))
      AND NOT e._type = "provenance"  -- don't self-reference
    =>
    CREATE provenance(e, "system", now()) {
      method = "auto_tracked"
    }

}