-- =============================================================================
-- ONTOLOGY: ProofInference
-- LEVEL: C (Advanced)
-- PURPOSE: Formal proofs with inference rules, assumptions, and validity tracking
-- =============================================================================

ontology ProofInference : Layer0 {

  -- ===========================================================================
  -- NODE TYPES
  -- ===========================================================================

  node Term {
    symbol: String [required],
    term_type: String?,               -- "constant", "variable", "function"
    arity: Int = 0
  }

  node Formula {
    expression: String [required],
    formula_type: String?,            -- "atomic", "compound"
    connective: String?               -- "and", "or", "not", "implies", "forall", "exists"
  }

  node Axiom : Formula {
    axiom_system: String?,
    axiom_name: String?
  }

  node Theorem : Formula {
    proven: Bool = false,
    name: String?
  }

  node Assumption : Formula {
    scope_id: String?,                -- which proof scope this assumption is in
    discharged: Bool = false
  }

  node InferenceRule {
    name: String [required, unique],
    description: String?,
    premises_count: Int [required],
    schema: String?                   -- pattern representation
  }

  node Proof {
    name: String?,
    status: String = "in_progress",   -- "in_progress", "complete", "invalid"
    started_at: Timestamp?,
    completed_at: Timestamp?
  }

  node ProofStep {
    step_number: Int [required],
    justification: String?,
    annotation: String?
  }

  node ProofBranch {
    branch_type: String?,             -- "main", "assumption", "case"
    label: String?
  }

  -- ===========================================================================
  -- EDGE TYPES
  -- ===========================================================================

  -- Formula structure
  edge subformula(parent: Formula, child: Formula) {
    position: Int?                    -- for ordered subformulas
  }

  edge contains_term(formula: Formula, term: Term) {}

  edge substitutes(original: Term, replacement: Term, in_formula: Formula) {}

  -- Proof structure
  edge proves(proof: Proof, conclusion: Theorem) {}

  edge has_step(proof: Proof, step: ProofStep) {}

  edge step_formula(step: ProofStep, formula: Formula) {}

  edge step_uses_rule(step: ProofStep, rule: InferenceRule) {}

  edge step_premise(step: ProofStep, premise: ProofStep) {
    premise_index: Int?               -- which premise slot
  }

  edge step_assumes(step: ProofStep, assumption: Assumption) {}

  edge discharges(step: ProofStep, assumption: Assumption) {}

  edge in_branch(step: ProofStep, branch: ProofBranch) {}

  edge branch_in_proof(branch: ProofBranch, proof: Proof) {}

  edge uses_axiom(step: ProofStep, axiom: Axiom) {}

  -- Higher-order: step validity
  edge step_validity(
    step: edge<has_step>,
    valid: Bool
  ) {
    checked_at: Timestamp?,
    checker: String?
  }

  -- Higher-order: proof dependency
  edge proof_depends_on(
    dependent: edge<proves>,
    dependency: edge<proves>
  ) {
    -- this proof uses a theorem from another proof
  }

  -- Higher-order: alternative proof
  edge alternative_proof(
    proof1: edge<proves>,
    proof2: edge<proves>
  ) {
    -- both proofs establish the same theorem
  }

  -- Higher-order: rule application validity
  edge valid_application(
    application: edge<step_uses_rule>,
    valid: Bool
  ) {
    reason: String?
  }

  -- ===========================================================================
  -- CONSTRAINTS
  -- ===========================================================================

  -- Step numbers must be positive and unique within proof
  constraint step_number_positive:
    s: ProofStep
    => s.step_number >= 1

  constraint step_number_unique:
    p: Proof, s1: ProofStep, s2: ProofStep,
    has_step(p, s1), has_step(p, s2)
    WHERE s1.id != s2.id
    => s1.step_number != s2.step_number

  -- Premises must come before the step that uses them
  constraint premise_before_conclusion:
    p: Proof, s1: ProofStep, s2: ProofStep,
    has_step(p, s1), has_step(p, s2),
    step_premise(s2, s1)
    => s1.step_number < s2.step_number

  -- Discharged assumption must be in scope
  constraint discharge_in_scope:
    s: ProofStep, a: Assumption,
    discharges(s, a)
    => EXISTS(s2: ProofStep, step_assumes(s2, a))
       AND s2.step_number <= s.step_number

  -- Premises count must match rule
  constraint correct_premise_count:
    s: ProofStep, r: InferenceRule,
    step_uses_rule(s, r)
    => r.premises_count = COUNT(p: ProofStep, step_premise(s, p))

  -- Complete proof must have valid conclusion
  constraint complete_proof_valid:
    p: Proof, t: Theorem,
    proves(p, t)
    WHERE p.status = "complete"
    => t.proven = true

  -- ===========================================================================
  -- RULES
  -- ===========================================================================

  -- Validate step application
  rule validate_step [priority: 10]:
    p: Proof, s: ProofStep, r: InferenceRule,
    has_step(p, s) AS hs,
    step_uses_rule(s, r) AS app
    WHERE NOT EXISTS(valid_application(app, _))
    =>
    -- For now, assume valid (real validator would check schema)
    CREATE valid_application(app, true) {
      reason = "auto_validated"
    },
    CREATE step_validity(hs, true) {
      checked_at = now(),
      checker = "proof_engine"
    }

  -- Mark proof complete when all steps valid and conclusion reached
  rule complete_proof [priority: 8]:
    p: Proof, t: Theorem,
    proves(p, t)
    WHERE p.status = "in_progress"
      AND NOT EXISTS(
        s: ProofStep, 
        has_step(p, s) AS hs,
        step_validity(hs, false)
      )
      AND EXISTS(
        final: ProofStep, f: Formula,
        has_step(p, final),
        step_formula(final, f)
        WHERE f.expression = t.expression
      )
    =>
    SET p.status = "complete",
    SET p.completed_at = now(),
    SET t.proven = true

  -- Detect alternative proofs
  rule find_alternative [priority: 3]:
    p1: Proof, p2: Proof, t: Theorem,
    proves(p1, t) AS pr1,
    proves(p2, t) AS pr2
    WHERE p1.id != p2.id
      AND p1.status = "complete"
      AND p2.status = "complete"
      AND NOT EXISTS(alternative_proof(pr1, pr2))
    =>
    CREATE alternative_proof(pr1, pr2)

  -- Propagate theorem to dependent proofs
  rule propagate_proven [priority: 5]:
    p1: Proof, p2: Proof, t1: Theorem, t2: Theorem,
    proves(p1, t1) AS pr1,
    proves(p2, t2) AS pr2,
    proof_depends_on(pr2, pr1)
    WHERE t1.proven = true AND p2.status = "in_progress"
    =>
    -- Dependency is satisfied, proof can proceed
    SET p2.annotation = "dependency_satisfied"

  -- Discharge assumption when implication proven
  rule auto_discharge [priority: 6]:
    p: Proof, s: ProofStep, a: Assumption, f: Formula,
    has_step(p, s),
    step_assumes(s, a),
    step_formula(s, f)
    WHERE f.connective = "implies"
      AND a.discharged = false
    =>
    SET a.discharged = true,
    CREATE discharges(s, a)

}