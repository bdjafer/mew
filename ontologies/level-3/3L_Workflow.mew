-- ===========================================================================
-- ONTOLOGY: 3L_Workflow
-- LEVEL: 3 (Dynamics)
-- SIZE: Long
-- DOMAIN: State machine / workflow execution engine
-- 
-- FEATURES TESTED:
--   • Complex state machine modeling
--   • Hyperedges (Transition with multiple participants)
--   • Many constraints (valid transitions, conditions)
--   • Rule ecosystem (state transitions, history)
--   • SPAWN in rules (create history entries)
--   • KILL in rules (cleanup)
--   • Manual rules (administrative actions)
--   • [prevent] on deletion
--   • Extensive edge attributes
--
-- @test:parse
-- @test:compile
-- @test:spawn
-- @test:link
-- @test:constraint:pass
-- @test:constraint:fail - Invalid state transition
-- @test:rule:trigger
-- @test:rule:chain
-- @test:higher-order - (setup for L4, transition metadata)
-- ===========================================================================

ontology Workflow {

  -- =========================================================================
  -- TYPE ALIASES
  -- =========================================================================
  
  type WorkItemStatus = String [in: ["draft", "active", "completed", "failed", "cancelled"]]
  type ConditionType = String [in: ["always", "expression", "approval", "timeout"]]
  type ActionType = String [in: ["assign", "notify", "update", "spawn", "external"]]

  -- =========================================================================
  -- NODE TYPES
  -- =========================================================================

  --- Definition of a workflow (template)
  node WorkflowDef {
    name: String [required, unique],
    description: String?,
    version: Int = 1,
    is_active: Bool = true,
    created_at: Timestamp = now()
  }

  --- A state in the workflow
  node State {
    name: String [required],
    description: String?,
    is_initial: Bool = false,
    is_final: Bool = false,
    timeout_minutes: Int?,
    on_enter_action: String?,
    on_exit_action: String?
  }

  --- A transition between states
  node Transition {
    name: String [required],
    description: String?,
    priority: Int = 0
  }

  --- A condition that must be met for transition
  node Condition {
    name: String?,
    condition_type: ConditionType = "always",
    expression: String?,
    description: String?
  }

  --- An action to perform during transition
  node Action {
    name: String?,
    action_type: ActionType = "notify",
    target: String?,
    parameters: String?,
    order: Int = 0
  }

  --- An instance of a workflow being executed
  node WorkItem {
    external_id: String?,
    status: WorkItemStatus = "draft",
    data: String?,
    created_at: Timestamp = now(),
    started_at: Timestamp?,
    completed_at: Timestamp?,
    failed_at: Timestamp?,
    failure_reason: String?
  }

  --- Historical record of state changes
  node StateHistory {
    entered_at: Timestamp [required],
    exited_at: Timestamp?,
    notes: String?
  }

  --- A user or system that can participate in workflows
  node Actor {
    name: String [required],
    actor_type: String = "user",
    email: String?,
    is_active: Bool = true
  }

  --- A role that actors can have
  node Role {
    name: String [required, unique],
    description: String?,
    can_approve: Bool = false,
    can_cancel: Bool = false
  }

  -- =========================================================================
  -- EDGE TYPES
  -- =========================================================================

  --- State belongs to workflow definition
  edge state_of(state: State, workflow: WorkflowDef) [
    on_kill_target: prevent
  ]

  --- Transition belongs to workflow definition
  edge transition_of(transition: Transition, workflow: WorkflowDef)

  --- Transition goes from state to state
  edge from_state(transition: Transition, state: State)
  
  edge to_state(transition: Transition, state: State)

  --- Transition has condition
  edge has_condition(transition: Transition, condition: Condition)

  --- Transition has action
  edge has_action(transition: Transition, action: Action)

  --- WorkItem is instance of workflow
  edge instance_of(item: WorkItem, workflow: WorkflowDef)

  --- WorkItem is currently in state
  edge current_state(item: WorkItem, state: State) [item -> 1]

  --- WorkItem has history entry
  edge has_history(item: WorkItem, history: StateHistory) [
    on_kill_source: cascade
  ]

  --- History entry is for state
  edge history_state(history: StateHistory, state: State)

  --- Actor has role
  edge has_role(actor: Actor, role: Role)

  --- Actor is assigned to work item
  edge assigned_actor(item: WorkItem, actor: Actor) {
    assigned_at: Timestamp = now(),
    assigned_by: String?
  }

  --- Role can perform transition
  edge can_perform(role: Role, transition: Transition)

  -- =========================================================================
  -- CONSTRAINTS
  -- =========================================================================

  --- Workflow must have exactly one initial state
  constraint single_initial_state [message: "Workflow must have exactly one initial state"]:
    w: WorkflowDef,
    s1: State, s2: State,
    state_of(s1, w), state_of(s2, w)
    WHERE s1.is_initial = true AND s2.is_initial = true AND s1.id != s2.id
    => false

  --- Workflow must have at least one initial state
  constraint has_initial_state [message: "Workflow must have an initial state"]:
    w: WorkflowDef
    WHERE w.is_active = true
    => EXISTS(s: State, state_of(s, w) WHERE s.is_initial = true)

  --- Transition must connect states in same workflow
  constraint transition_same_workflow [message: "Transition must connect states in the same workflow"]:
    t: Transition, s1: State, s2: State, w1: WorkflowDef, w2: WorkflowDef,
    from_state(t, s1), to_state(t, s2),
    state_of(s1, w1), state_of(s2, w2)
    => w1.id = w2.id

  --- Cannot transition from final state
  constraint no_transition_from_final [message: "Cannot define transition from final state"]:
    t: Transition, s: State,
    from_state(t, s)
    => s.is_final = false

  --- Active work item must have current state
  constraint active_has_state [message: "Active work item must have a current state"]:
    item: WorkItem
    WHERE item.status = "active"
    => EXISTS(s: State, current_state(item, s))

  --- Work item state must be from its workflow
  constraint item_state_matches_workflow [message: "Work item state must be from its workflow definition"]:
    item: WorkItem, s: State, w1: WorkflowDef, w2: WorkflowDef,
    current_state(item, s),
    instance_of(item, w1),
    state_of(s, w2)
    => w1.id = w2.id

  -- =========================================================================
  -- RULES
  -- =========================================================================

  --- When work item starts, move to initial state
  rule start_workflow [priority: 100]:
    item: WorkItem, w: WorkflowDef, initial: State,
    instance_of(item, w),
    state_of(initial, w)
    WHERE item.status = "active" 
      AND item.started_at = null
      AND initial.is_initial = true
      AND NOT EXISTS(s: State, current_state(item, s))
    =>
    SET item.started_at = now(),
    LINK current_state(item, initial),
    SPAWN h: StateHistory { entered_at = now() },
    LINK has_history(item, h),
    LINK history_state(h, initial)

  --- When work item reaches final state, complete it
  rule complete_on_final [priority: 50]:
    item: WorkItem, s: State,
    current_state(item, s)
    WHERE item.status = "active" AND s.is_final = true AND item.completed_at = null
    =>
    SET item.status = "completed",
    SET item.completed_at = now()

  --- Record state exit in history when state changes
  rule record_state_exit [priority: 90]:
    item: WorkItem, h: StateHistory, old_state: State,
    has_history(item, h),
    history_state(h, old_state),
    current_state(item, old_state)
    WHERE h.exited_at = null AND item.status = "active"
      AND EXISTS(
        new_state: State, current_state(item, new_state)
        WHERE new_state.id != old_state.id
      )
    =>
    SET h.exited_at = now()

  --- Manual rule: Cancel work item (requires explicit invocation)
  rule cancel_workflow [manual]:
    item: WorkItem
    WHERE item.status = "active"
    =>
    SET item.status = "cancelled",
    SET item.completed_at = now()

  --- Manual rule: Fail work item with reason
  rule fail_workflow [manual]:
    item: WorkItem
    WHERE item.status = "active"
    =>
    SET item.status = "failed",
    SET item.failed_at = now()

}