{
  "specs": [
    {
      "file": "architecture.md",
      "title": "MEW System Architecture",
      "category": "root",
      "summary": "**Version:** 1.0 **Status:** Design Specification **Purpose:** Minimal Executable World — a self-describing higher-order hypergraph database",
      "headings": [
        "MEW System Architecture",
        "Part I: Foundations",
        "1. Design Philosophy",
        "1.1 Core Principles",
        "1.2 What MEW Is Good For",
        "1.3 What MEW Is Not",
        "2. Architecture Overview",
        "2.1 Component Map (13 Components)",
        "2.2 Component Responsibilities",
        "2.3 Dependency Graph"
      ],
      "keywords": [
        "system",
        "architecture",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "walk",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit",
        "rollback"
      ]
    },
    {
      "file": "core/1_LANGUAGE.md",
      "title": "MEW Language Specification",
      "category": "core",
      "summary": "**Version:** 2.1 **Status:** Stable Core **Scope:** Lexical structure, scalar types, core type expressions, core expressions",
      "headings": [
        "MEW Language Specification",
        "Part I: Foundations",
        "1. Introduction",
        "1.1 Purpose",
        "1.2 Modular Specification Structure",
        "1.3 Conformance",
        "1.4 Notation",
        "1.4.1 Grammar Notation",
        "1.4.2 Requirement Levels",
        "2. Lexical Structure"
      ],
      "keywords": [
        "language",
        "specification",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "union",
        "type",
        "ontology",
        "begin"
      ]
    },
    {
      "file": "core/2_LAYER0.md",
      "title": "MEW Language Specification",
      "category": "core",
      "summary": "**Version:** 2.1 **Status:** Stable Foundation **Scope:** Minimal kernel meta-schema and extension mechanisms",
      "headings": [
        "MEW Language Specification",
        "Part II: Layer 0 Core",
        "0. Overview",
        "0.1 Purpose",
        "0.2 Design Principle: Minimal Core",
        "0.3 Document Scope",
        "0.4 Reserved Namespace",
        "1. Scalar Types",
        "1.1 Default Value Serialization",
        "1.2 Dynamic Defaults"
      ],
      "keywords": [
        "language",
        "specification",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "union",
        "type",
        "ontology",
        "transaction",
        "commit"
      ]
    },
    {
      "file": "core/3_DSL.md",
      "title": "MEW Language Specification",
      "category": "core",
      "summary": "**Version:** 2.1 **Status:** Stable Core **Scope:** Schema definition syntax",
      "headings": [
        "MEW Language Specification",
        "Part III: Ontology DSL",
        "1. Overview",
        "1.1 Purpose",
        "1.2 Compilation Model",
        "1.3 File Structure",
        "2. Ontology Declaration",
        "2.1 Syntax",
        "2.2 Examples",
        "2.3 Implicit Ontology"
      ],
      "keywords": [
        "language",
        "specification",
        "match",
        "spawn",
        "link",
        "set",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "union",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "declarations/constraint.md",
      "title": "Constraint-Declaration",
      "category": "declarations",
      "summary": "Constraint declarations define invariants that must always hold in the graph. Each constraint specifies a pattern to match and a condition that must be true for all matches. Constraints are the foundation of graph validation, enforcing business rules...",
      "headings": [
        "Spec: Constraint Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Reading Constraints",
        "Constraint Names Required",
        "Hard vs Soft Constraints"
      ],
      "keywords": [
        "constraint-declaration",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology",
        "transaction",
        "commit",
        "rollback"
      ]
    },
    {
      "file": "declarations/edge.md",
      "title": "Edge-Declaration",
      "category": "declarations",
      "summary": "Edge type declarations define the kinds of relationships that can exist between nodes in the graph. Each edge type specifies a name, a signature of typed parameters identifying the connected endpoints, optional modifiers for structural constraints an...",
      "headings": [
        "Spec: Edge Type Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Edge Signature",
        "Symmetric Modifier",
        "No Self Modifier"
      ],
      "keywords": [
        "edge-declaration",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "union",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "declarations/node.md",
      "title": "Node-Declaration",
      "category": "declarations",
      "summary": "Node type declarations define the kinds of entities that can exist in the graph. Each node type specifies a name, optional parent types for inheritance, and a set of typed attributes with optional modifiers and defaults. Node types form the structura...",
      "headings": [
        "Spec: Node Type Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Node Type Identity",
        "Type Inheritance",
        "Abstract and Sealed Modifiers"
      ],
      "keywords": [
        "node-declaration",
        "match",
        "spawn",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "indexed",
        "optional",
        "type",
        "ontology"
      ]
    },
    {
      "file": "declarations/node_modifiers.md",
      "title": "Node Modifiers",
      "category": "declarations",
      "summary": "Node modifiers `abstract` and `sealed` control the instantiation and inheritance behavior of node types. Abstract types cannot be instantiated directly but serve as base types for inheritance hierarchies. Sealed types cannot be inherited by user onto...",
      "headings": [
        "Spec: Node Modifiers (abstract, sealed)",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Abstract Types",
        "Sealed Types",
        "Combined Modifiers"
      ],
      "keywords": [
        "node",
        "modifiers",
        "match",
        "spawn",
        "set",
        "return",
        "where",
        "edge",
        "constraint",
        "required",
        "unique",
        "optional",
        "type",
        "ontology"
      ]
    },
    {
      "file": "declarations/ontology.md",
      "title": "Ontology",
      "category": "declarations",
      "summary": "The `ontology` declaration defines a named schema container that groups related type, edge, constraint, and rule declarations. Ontologies support inheritance, enabling schema composition and extension. When no explicit ontology declaration is present...",
      "headings": [
        "Spec: Ontology Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Implicit Ontology",
        "Inheritance Semantics",
        "Additive-Only Inheritance"
      ],
      "keywords": [
        "ontology",
        "match",
        "spawn",
        "kill",
        "link",
        "set",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type"
      ]
    },
    {
      "file": "declarations/policy.md",
      "title": "Policy",
      "category": "declarations",
      "summary": "Policy declarations define actor-based access control rules for graph operations. Each policy specifies when an operation is allowed or denied based on the actor performing it, the operation type, and the target. Policies are evaluated before any mut...",
      "headings": [
        "Spec: Policy Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Policy vs Constraints",
        "Default-Deny Semantics",
        "Priority Resolution"
      ],
      "keywords": [
        "policy",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "optional",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit",
        "rollback"
      ]
    },
    {
      "file": "declarations/rule.md",
      "title": "Rule",
      "category": "declarations",
      "summary": "A rule declaration defines a reactive transformation: when a graph pattern matches, execute a sequence of actions. Rules enable self-maintaining graphs where derived data is computed automatically. Rules fire within transactions, after user mutations...",
      "headings": [
        "Spec: Rule Declaration",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Rule Modifiers",
        "Execution Order",
        "Variable Scoping"
      ],
      "keywords": [
        "rule",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology",
        "transaction"
      ]
    },
    {
      "file": "declarations/type_alias.md",
      "title": "Type Alias",
      "category": "declarations",
      "summary": "Type aliases define reusable type expressions with optional modifiers. They reduce repetition, establish domain vocabulary, and enable union types for polymorphic signatures. Type aliases are purely syntactic sugar expanded at compile time and do not...",
      "headings": [
        "Spec: Type Alias",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Scalar Aliases",
        "Union Aliases",
        "Alias Chaining"
      ],
      "keywords": [
        "type",
        "alias",
        "match",
        "where",
        "node",
        "edge",
        "required",
        "unique",
        "indexed",
        "optional",
        "union",
        "ontology"
      ]
    },
    {
      "file": "expressions/aggregations.md",
      "title": "Aggregations",
      "category": "expressions",
      "summary": "Aggregation functions compute summary values over sets of matched data. They enable counting, summing, averaging, and collecting results from pattern matches. Aggregations can appear in RETURN clauses for result computation and directly in WHERE clau...",
      "headings": [
        "Spec: Aggregations",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Aggregation Functions",
        "Grouping Behavior",
        "DISTINCT Modifier"
      ],
      "keywords": [
        "aggregations",
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "unique",
        "optional",
        "type"
      ]
    },
    {
      "file": "expressions/context_functions.md",
      "title": "Context-Functions",
      "category": "expressions",
      "summary": "Context functions provide access to the execution context (actor, operation, target) within policy conditions. These functions enable policies to make decisions based on who is performing an operation, what operation is being performed, and what enti...",
      "headings": [
        "Spec: Context Functions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Function Signatures and Behavior",
        "Valid Operations",
        "Return Value Semantics"
      ],
      "keywords": [
        "context-functions",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "type"
      ]
    },
    {
      "file": "expressions/exists.md",
      "title": "Exists",
      "category": "expressions",
      "summary": "Exists patterns test for the presence or absence of graph structure within constraint conditions and WHERE clauses. Most useful constraints need to express \"there exists\" or \"there does not exist\" conditions. Without this, constraints can only reason...",
      "headings": [
        "Spec: Exists",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Evaluation",
        "Variable Scoping",
        "Typing"
      ],
      "keywords": [
        "exists",
        "match",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "unique",
        "type"
      ]
    },
    {
      "file": "expressions/id_references.md",
      "title": "Id References",
      "category": "expressions",
      "summary": "ID references provide a syntax for directly referencing nodes and edges by their unique identifiers. This enables direct entity lookup without pattern matching, which is useful for the INSPECT statement, WALK starting points, and any context where a ...",
      "headings": [
        "Spec: ID References",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "ID Reference Syntax",
        "Type",
        "Resolution"
      ],
      "keywords": [
        "references",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "walk",
        "return",
        "where",
        "node",
        "edge",
        "required",
        "unique",
        "type",
        "begin"
      ]
    },
    {
      "file": "expressions/null_handling.md",
      "title": "Null Handling",
      "category": "expressions",
      "summary": "Null handling provides expressions for working with optional values (`T?` types). Optional types require ergonomic null handling - every optional attribute access needs a way to provide defaults or check for null.",
      "headings": [
        "Spec: Null Handling",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Operators",
        "Examples",
        "Semantics",
        "Coalesce Operator (??)",
        "COALESCE Function"
      ],
      "keywords": [
        "null",
        "handling",
        "match",
        "link",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "indexed",
        "optional",
        "type"
      ]
    },
    {
      "file": "expressions/numeric_functions.md",
      "title": "Numeric Functions",
      "category": "expressions",
      "summary": "Numeric functions provide mathematical operations on `Int` and `Float` values. These functions support absolute value computation, finding minimum and maximum values, and rounding operations. They are essential for data analysis, aggregation, and mat...",
      "headings": [
        "Spec: Numeric Functions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Function Signatures and Behavior",
        "Type Rules",
        "Detailed Behavior"
      ],
      "keywords": [
        "numeric",
        "functions",
        "match",
        "set",
        "return",
        "where",
        "type",
        "transaction"
      ]
    },
    {
      "file": "expressions/parameters.md",
      "title": "Parameters",
      "category": "expressions",
      "summary": "Parameters enable safe, reusable queries with external values. They prevent injection attacks by ensuring values are always treated as data (never as identifiers or operators), and enable query plan caching for improved performance. Parameters are re...",
      "headings": [
        "Spec: Parameters",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Parameter Binding",
        "Type Checking",
        "Parameter Scope"
      ],
      "keywords": [
        "parameters",
        "match",
        "spawn",
        "kill",
        "link",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "optional",
        "type"
      ]
    },
    {
      "file": "expressions/string_functions.md",
      "title": "String Functions",
      "category": "expressions",
      "summary": "String functions provide operations for manipulating and inspecting string values. These functions are essential for data transformation, filtering, and text processing in queries and rules. They operate on `String` values and support common text ope...",
      "headings": [
        "Spec: String Functions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Function Signatures and Behavior",
        "Type Rules",
        "Edge Cases"
      ],
      "keywords": [
        "string",
        "functions",
        "match",
        "set",
        "return",
        "where",
        "edge",
        "indexed",
        "type",
        "begin"
      ]
    },
    {
      "file": "expressions/time_functions.md",
      "title": "Time-Functions",
      "category": "expressions",
      "summary": "Time functions provide access to temporal values within MEW expressions. MEW provides two distinct time concepts: wall time (real-world clock) and logical time (abstract tick counter), plus a configurable `now()` alias.",
      "headings": [
        "Spec: Time Functions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Function Signatures",
        "wall_time()",
        "logical_time()"
      ],
      "keywords": [
        "time-functions",
        "match",
        "spawn",
        "kill",
        "link",
        "set",
        "return",
        "where",
        "node",
        "constraint",
        "ontology"
      ]
    },
    {
      "file": "expressions/timestamp_functions.md",
      "title": "Timestamp Functions",
      "category": "expressions",
      "summary": "Timestamp functions provide operations for working with temporal values. These functions enable querying the current time, extracting date/time components from timestamps, and parsing timestamp values from strings. All timestamp operations use UTC (C...",
      "headings": [
        "Spec: Timestamp Functions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Function Signatures and Behavior",
        "Type Rules",
        "now() Semantics"
      ],
      "keywords": [
        "timestamp",
        "functions",
        "match",
        "set",
        "return",
        "where",
        "type",
        "transaction"
      ]
    },
    {
      "file": "expressions/type_checking.md",
      "title": "Type Checking",
      "category": "expressions",
      "summary": "The type check expression `x:Type` tests whether a value is of a specific type at runtime. Returns `true` if the value's type equals or inherits from the specified type.",
      "headings": [
        "Spec: Type Checking Expression",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Evaluation",
        "Inheritance",
        "Null Handling"
      ],
      "keywords": [
        "type",
        "checking",
        "match",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "union"
      ]
    },
    {
      "file": "literals/duration_literals.md",
      "title": "Duration Literals",
      "category": "literals",
      "summary": "Duration literals provide human-readable syntax for duration values. Instead of `86400000`, write `1.day`. Instead of `3600000`, write `1.hour`.",
      "headings": [
        "Spec: Duration Literals",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Unit Conversion",
        "Evaluation",
        "Arithmetic"
      ],
      "keywords": [
        "duration",
        "literals",
        "match",
        "return",
        "where",
        "node",
        "constraint",
        "type"
      ]
    },
    {
      "file": "literals/timestamp_literals.md",
      "title": "Timestamp Literals",
      "category": "literals",
      "summary": "Timestamp literals provide human-readable syntax for timestamp values, avoiding manual millisecond calculations. Instead of `1705312200000`, write `@2024-01-15T10:30:00Z`.",
      "headings": [
        "Spec: Timestamp Literals",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Evaluation",
        "Date-Only Form",
        "Timezone Handling"
      ],
      "keywords": [
        "timestamp",
        "literals",
        "match",
        "set",
        "return",
        "where",
        "node",
        "constraint",
        "type"
      ]
    },
    {
      "file": "meta-roadmap.md",
      "title": "MEW Implementation Meta-Roadmap",
      "category": "root",
      "summary": "**Purpose:** A compass for autonomous implementation. Not a task list — a behavior repertoire with selection heuristics.",
      "headings": [
        "MEW Implementation Meta-Roadmap",
        "1. Terminal Condition",
        "2. Canonical Behaviors",
        "B1: Fix Bug",
        "B2: Implement Feature",
        "B3: Write Tests",
        "B4: Improve Testgen",
        "B5: Create Ontology",
        "B6: Discover Edge Cases",
        "B7: Refine Specification"
      ],
      "keywords": [
        "implementation",
        "meta-roadmap",
        "match",
        "return",
        "where",
        "edge",
        "constraint",
        "ontology",
        "transaction",
        "commit"
      ]
    },
    {
      "file": "modifiers/acyclic_edges.md",
      "title": "Acyclic Edges",
      "category": "modifiers",
      "summary": "The `[acyclic]` modifier prevents cycles through an edge type. If `parent_of(a, b)` and `parent_of(b, c)` exist, then `parent_of(c, a)` is forbidden. Essential for hierarchies, dependencies, and directed acyclic graphs (DAGs).",
      "headings": [
        "Spec: Acyclic Edges",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Constraint",
        "Cycle Detection",
        "Transitivity"
      ],
      "keywords": [
        "acyclic",
        "edges",
        "match",
        "link",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/cardinality.md",
      "title": "Cardinality",
      "category": "modifiers",
      "summary": "Cardinality modifiers constrain how many edges of a given type can connect to a node, enabling one-to-one, one-to-many, and many-to-many relationship modeling.",
      "headings": [
        "Spec: Cardinality Constraints",
        "1. Overview",
        "2. Syntax",
        "2.1 Grammar Additions",
        "2.2 Keywords Added",
        "2.3 Examples",
        "3. Semantics",
        "3.1 Cardinality Values",
        "3.2 Which Parameter",
        "3.3 Multiple Cardinalities"
      ],
      "keywords": [
        "cardinality",
        "spawn",
        "link",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "optional",
        "type",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "modifiers/default_values.md",
      "title": "Default Values",
      "category": "modifiers",
      "summary": "Default values provide automatic initialization for attributes when they are not explicitly provided at SPAWN or LINK time. They support both static literal values and dynamic expressions evaluated at entity creation time.",
      "headings": [
        "Spec: Default Values",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Static Defaults",
        "Dynamic Defaults",
        "Arithmetic in Defaults"
      ],
      "keywords": [
        "default",
        "values",
        "match",
        "spawn",
        "link",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "modifiers/edge_symmetry.md",
      "title": "Edge Symmetry",
      "category": "modifiers",
      "summary": "The `[symmetric]` modifier declares that an edge is order-independent: `edge(a, b)` equals `edge(b, a)`. Useful for mutual relationships like friendship, similarity, or collaboration where directionality is meaningless.",
      "headings": [
        "Spec: Edge Symmetry",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Type Requirement",
        "Storage",
        "Creation Deduplication"
      ],
      "keywords": [
        "edge",
        "symmetry",
        "match",
        "link",
        "return",
        "where",
        "node",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/enum_constraint.md",
      "title": "Enum Constraint",
      "category": "modifiers",
      "summary": "The `[in: [...]]` modifier restricts an attribute's value to a fixed set of allowed values. It provides type-safe enumeration without requiring a separate enum type definition.",
      "headings": [
        "Spec: Enum Constraint",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Supported Types",
        "Validation Timing",
        "Null Handling"
      ],
      "keywords": [
        "enum",
        "constraint",
        "match",
        "spawn",
        "set",
        "where",
        "node",
        "edge",
        "required",
        "unique",
        "indexed",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/format_validation.md",
      "title": "Format Validation",
      "category": "modifiers",
      "summary": "The `[format: name]` modifier validates string attributes against built-in format patterns. Provides common validations (email, URL, UUID) without writing regex patterns.",
      "headings": [
        "Spec: Format Validation",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Built-in Formats",
        "Validation",
        "Null Handling"
      ],
      "keywords": [
        "format",
        "validation",
        "match",
        "spawn",
        "set",
        "return",
        "where",
        "node",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/indexed.md",
      "title": "Indexed",
      "category": "modifiers",
      "summary": "The `[indexed]` modifier creates an index on an attribute for faster lookups. Indexes speed up queries that filter or sort by the indexed attribute, at the cost of additional storage and write overhead.",
      "headings": [
        "Spec: Indexed",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Index Types",
        "Ascending vs Descending",
        "Unique Implies Indexed"
      ],
      "keywords": [
        "indexed",
        "match",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/length_constraint.md",
      "title": "Length Constraint",
      "category": "modifiers",
      "summary": "The `[length: N..M]` modifier constrains the character length of a string attribute. It ensures strings are within acceptable bounds, preventing both empty strings and excessively long values.",
      "headings": [
        "Spec: Length Constraint",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Range Interpretation",
        "Validation Timing",
        "Null Handling"
      ],
      "keywords": [
        "length",
        "constraint",
        "match",
        "spawn",
        "set",
        "where",
        "node",
        "required",
        "unique",
        "optional",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/no_self.md",
      "title": "No Self",
      "category": "modifiers",
      "summary": "The `[no_self]` modifier prevents an edge from connecting a node to itself. It ensures that self-loops are forbidden for edges where such connections would be semantically invalid.",
      "headings": [
        "Spec: No Self",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Self-Loop Detection",
        "Applicability",
        "With Type Inheritance"
      ],
      "keywords": [
        "self",
        "spawn",
        "link",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/range_constraint.md",
      "title": "Range Constraint",
      "category": "modifiers",
      "summary": "Range constraint modifiers (`>=`, `<=`, `>`, `<`, and `N..M`) constrain numeric attribute values to specified bounds. They enforce domain-specific limits on integers and floats.",
      "headings": [
        "Spec: Range Constraint",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Comparison Modifiers",
        "Range Shorthand",
        "Combining Bounds"
      ],
      "keywords": [
        "range",
        "constraint",
        "match",
        "spawn",
        "set",
        "where",
        "node",
        "required",
        "type",
        "ontology",
        "transaction"
      ]
    },
    {
      "file": "modifiers/referential_actions.md",
      "title": "Referential Actions",
      "category": "modifiers",
      "summary": "Referential actions specify what happens to edges when a connected node is killed, enabling cascade delete, unlinking, or prevention.",
      "headings": [
        "Spec: Referential Actions",
        "1. Overview",
        "2. Syntax",
        "2.1 Grammar Additions",
        "2.2 Keywords Added",
        "2.3 Examples",
        "3. Semantics",
        "3.1 Actions",
        "3.2 Source vs Target",
        "3.3 Default Behavior"
      ],
      "keywords": [
        "referential",
        "actions",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "node",
        "edge",
        "constraint",
        "required",
        "type",
        "ontology",
        "transaction"
      ]
    },
    {
      "file": "modifiers/regex_validation.md",
      "title": "Regex Validation",
      "category": "modifiers",
      "summary": "The `[match: \"pattern\"]` modifier validates string attributes against a custom regular expression. For domain-specific patterns not covered by built-in formats.",
      "headings": [
        "Spec: Regex Validation",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Regex Flavor",
        "Anchoring",
        "Validation Timing"
      ],
      "keywords": [
        "regex",
        "validation",
        "match",
        "spawn",
        "set",
        "where",
        "node",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/required.md",
      "title": "Required",
      "category": "modifiers",
      "summary": "The `[required]` modifier ensures an attribute must have a non-null value. It prevents creation of entities without the attribute and prevents setting the attribute to null after creation.",
      "headings": [
        "Spec: Required",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Validation Timing",
        "Behavior Table",
        "Required with Default"
      ],
      "keywords": [
        "required",
        "spawn",
        "set",
        "where",
        "node",
        "constraint",
        "unique",
        "type",
        "ontology"
      ]
    },
    {
      "file": "modifiers/soft_constraints.md",
      "title": "Soft Constraints",
      "category": "modifiers",
      "summary": "Soft constraints warn instead of reject. They document best practices, data quality expectations, or guidelines that shouldn't block operations. Hard constraints are requirements; soft constraints are recommendations.",
      "headings": [
        "Spec: Soft Constraints",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Hard vs Soft",
        "Evaluation Order",
        "Message Modifier"
      ],
      "keywords": [
        "soft",
        "constraints",
        "match",
        "spawn",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "modifiers/unique.md",
      "title": "Unique",
      "category": "modifiers",
      "summary": "The `[unique]` modifier ensures an attribute value is unique across all instances of a type. No two entities of the same type (or its subtypes) can have the same non-null value for a unique attribute.",
      "headings": [
        "Spec: Unique",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Uniqueness Scope",
        "Null Handling",
        "Implicit Indexing"
      ],
      "keywords": [
        "unique",
        "spawn",
        "set",
        "where",
        "node",
        "constraint",
        "required",
        "indexed",
        "optional",
        "type",
        "ontology"
      ]
    },
    {
      "file": "patterns/edge_patterns.md",
      "title": "Edge Patterns",
      "category": "patterns",
      "summary": "Edge patterns match relationships between nodes in the graph. They specify edge type, source and target nodes, and optionally bind the edge itself to a variable for attribute access. Edge patterns are the primary mechanism for expressing structural r...",
      "headings": [
        "Spec: Edge Patterns",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Edge Matching",
        "Edge Binding with AS",
        "Target References"
      ],
      "keywords": [
        "edge",
        "patterns",
        "match",
        "return",
        "where",
        "node",
        "constraint",
        "required",
        "unique",
        "optional",
        "type"
      ]
    },
    {
      "file": "patterns/negative_patterns.md",
      "title": "Negative Patterns",
      "category": "patterns",
      "summary": "Negative patterns test for the absence of graph structure using `NOT EXISTS`. They enable queries and constraints that reason about what does not exist: unassigned tasks, orphan nodes, missing relationships. Without negative patterns, queries can onl...",
      "headings": [
        "Spec: Negative Patterns",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Evaluation",
        "Variable Scoping",
        "Nested WHERE Clauses"
      ],
      "keywords": [
        "negative",
        "patterns",
        "match",
        "spawn",
        "link",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "optional"
      ]
    },
    {
      "file": "patterns/node_patterns.md",
      "title": "Node Patterns",
      "category": "patterns",
      "summary": "Node patterns are the fundamental building blocks for matching nodes in graph queries and constraints. They bind variables to nodes that satisfy type constraints, enabling subsequent filtering, projection, and mutation operations. Without node patter...",
      "headings": [
        "Spec: Node Patterns",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Variable Binding",
        "Type Matching",
        "Anonymous Nodes"
      ],
      "keywords": [
        "node",
        "patterns",
        "match",
        "set",
        "return",
        "where",
        "edge",
        "constraint",
        "required",
        "unique",
        "union",
        "type"
      ]
    },
    {
      "file": "patterns/transitive_patterns.md",
      "title": "Feature: Transitive Patterns",
      "category": "patterns",
      "summary": "Transitive patterns match paths of one or more (`+`) or zero or more (`*`) edges, enabling reachability queries and cycle detection without explicit recursion.",
      "headings": [
        "Feature: Transitive Patterns",
        "1. Overview",
        "2. Syntax",
        "2.1 Grammar Additions",
        "2.2 Keywords Added",
        "2.3 Examples",
        "3. Semantics",
        "3.1 Operators",
        "3.2 Evaluation",
        "3.3 Depth Limits"
      ],
      "keywords": [
        "feature:",
        "transitive",
        "patterns",
        "match",
        "walk",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "type"
      ]
    },
    {
      "file": "statements/ack.md",
      "title": "Ack",
      "category": "statements",
      "summary": "ACK and NACK statements acknowledge or reject message deliveries in consume mode watches. ACK confirms successful processing, causing the message to be deleted from the graph. NACK indicates processing failure, causing the message to be redelivered o...",
      "headings": [
        "Spec: ACK / NACK",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "ACK Behavior",
        "NACK Behavior",
        "NACK with no_retry"
      ],
      "keywords": [
        "match",
        "link",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type"
      ]
    },
    {
      "file": "statements/admin.md",
      "title": "Admin",
      "category": "statements",
      "summary": "Administration statements manage the schema, indexes, and engine state. They include loading and extending ontologies, inspecting schema metadata with SHOW statements, and creating/dropping indexes for query optimization. These operations are essenti...",
      "headings": [
        "Spec: Administration Statements",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "LOAD ONTOLOGY",
        "EXTEND ONTOLOGY",
        "SHOW Statements"
      ],
      "keywords": [
        "admin",
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "indexed",
        "type",
        "ontology",
        "transaction"
      ]
    },
    {
      "file": "statements/distinct.md",
      "title": "Distinct",
      "category": "statements",
      "summary": "DISTINCT removes duplicate rows from the result set. It can be applied to the entire RETURN clause to deduplicate rows, or used within aggregate functions like COUNT(DISTINCT x) to count unique values.",
      "headings": [
        "Spec: DISTINCT",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "RETURN DISTINCT",
        "Row Equality",
        "DISTINCT on Single Value"
      ],
      "keywords": [
        "distinct",
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "unique",
        "optional",
        "type"
      ]
    },
    {
      "file": "statements/explain.md",
      "title": "Explain",
      "category": "statements",
      "summary": "Debug statements help understand query execution and performance. EXPLAIN shows the execution plan for a statement without executing it, revealing how the query optimizer plans to retrieve data. PROFILE executes the statement and returns actual perfo...",
      "headings": [
        "Spec: EXPLAIN and PROFILE",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "EXPLAIN",
        "Plan Components",
        "PROFILE"
      ],
      "keywords": [
        "explain",
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "indexed",
        "type"
      ]
    },
    {
      "file": "statements/inspect.md",
      "title": "Inspect",
      "category": "statements",
      "summary": "INSPECT retrieves a specific node or edge by its unique identifier. Unlike MATCH which finds patterns, INSPECT provides direct access to a known entity. It returns the complete entity data or a projection of specific attributes, and gracefully handle...",
      "headings": [
        "Spec: INSPECT",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "ID Reference Syntax",
        "Default Return",
        "Projection"
      ],
      "keywords": [
        "inspect",
        "match",
        "return",
        "node",
        "edge",
        "unique",
        "type"
      ]
    },
    {
      "file": "statements/kill.md",
      "title": "Kill",
      "category": "statements",
      "summary": "KILL removes a node from the graph. It handles connected edges according to ontology-defined `on_kill_*` modifiers, supports cascade behavior, and can operate on single nodes by ID or bulk nodes via pattern matching.",
      "headings": [
        "Spec: KILL",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Target Resolution",
        "Edge Handling",
        "CASCADE Override"
      ],
      "keywords": [
        "kill",
        "match",
        "link",
        "unlink",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "type",
        "ontology"
      ]
    },
    {
      "file": "statements/limit_offset.md",
      "title": "Limit Offset",
      "category": "statements",
      "summary": "LIMIT restricts the number of rows returned by a query. OFFSET skips a specified number of rows before returning results. Together, they enable pagination and top-N queries essential for handling large result sets efficiently.",
      "headings": [
        "Spec: LIMIT and OFFSET",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "LIMIT",
        "OFFSET",
        "Evaluation Order"
      ],
      "keywords": [
        "limit",
        "offset",
        "match",
        "set",
        "return",
        "where",
        "node",
        "indexed"
      ]
    },
    {
      "file": "statements/link.md",
      "title": "Link",
      "category": "statements",
      "summary": "LINK creates a new edge connecting nodes in the graph. It supports multiple target resolution methods (ID, pattern, inline spawn), edge attributes, uniqueness constraints, and the idempotent `LINK IF NOT EXISTS` variant for safe edge creation.",
      "headings": [
        "Spec: LINK",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Target Resolution",
        "AS Binding in Inline SPAWN",
        "Edge Attributes"
      ],
      "keywords": [
        "link",
        "match",
        "spawn",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "type",
        "ontology",
        "commit"
      ]
    },
    {
      "file": "statements/match.md",
      "title": "Match",
      "category": "statements",
      "summary": "MATCH finds all subgraphs matching a pattern. It is the primary read operation in MEW, enabling graph traversal and data retrieval through declarative pattern matching against the graph structure.",
      "headings": [
        "Spec: MATCH",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "RETURN Clause Requirement",
        "MATCH in Different Contexts",
        "Pattern Matching"
      ],
      "keywords": [
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "required",
        "unique",
        "optional",
        "union",
        "type",
        "begin"
      ]
    },
    {
      "file": "statements/optional_match.md",
      "title": "Optional Match",
      "category": "statements",
      "summary": "OPTIONAL MATCH attempts to match a pattern, but returns NULL for unmatched variables instead of filtering out the row. This enables left-outer-join semantics in graph queries, allowing retrieval of entities even when optional relationships do not exi...",
      "headings": [
        "Spec: OPTIONAL MATCH",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Basic Behavior",
        "Comparison with Regular MATCH",
        "WHERE on OPTIONAL MATCH"
      ],
      "keywords": [
        "optional",
        "match",
        "return",
        "where",
        "edge",
        "required"
      ]
    },
    {
      "file": "statements/order_by.md",
      "title": "Order By",
      "category": "statements",
      "summary": "ORDER BY sorts the result set of a query based on one or more expressions. It allows ascending or descending ordering and supports expressions, aliases, and multiple sort keys for complex ordering requirements.",
      "headings": [
        "Spec: ORDER BY",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Default Direction",
        "Sort Direction",
        "Multiple Sort Keys"
      ],
      "keywords": [
        "order",
        "match",
        "set",
        "return",
        "where",
        "edge",
        "type",
        "begin"
      ]
    },
    {
      "file": "statements/returning.md",
      "title": "Returning",
      "category": "statements",
      "summary": "The RETURNING clause controls what data is returned after a mutation operation (SPAWN, KILL, LINK, UNLINK, SET). By default, mutations return minimal information, but RETURNING allows retrieving the ID, all attributes, or specific fields of created/m...",
      "headings": [
        "Spec: RETURNING Clause",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Default Behavior",
        "RETURNING id",
        "RETURNING *"
      ],
      "keywords": [
        "returning",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "type"
      ]
    },
    {
      "file": "statements/session.md",
      "title": "Session",
      "category": "statements",
      "summary": "Session statements bind an actor to a session, establishing the identity context for all subsequent operations. The actor determines what policy checks apply. Sessions without an explicit actor binding operate in system context, which is unrestricted...",
      "headings": [
        "Spec: SESSION",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Actor Binding",
        "System Context",
        "Session Nesting"
      ],
      "keywords": [
        "session",
        "match",
        "spawn",
        "link",
        "set",
        "return",
        "where",
        "node",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "statements/set.md",
      "title": "Set",
      "category": "statements",
      "summary": "SET modifies attribute values on existing nodes or edges. It supports single attribute updates, block syntax for multiple attributes, computed values using expressions, and bulk updates via pattern matching.",
      "headings": [
        "Spec: SET",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Single Attribute Update",
        "Multiple Attributes (Block Syntax)",
        "Alternative: Separate Statements"
      ],
      "keywords": [
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "optional",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "statements/spawn.md",
      "title": "Spawn",
      "category": "statements",
      "summary": "SPAWN creates a new node in the graph. It is the fundamental operation for introducing entities into the graph, supporting attribute initialization, default values, and returning clause to control what data is returned after creation.",
      "headings": [
        "Spec: SPAWN",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Node Creation",
        "Attribute Values",
        "Validation"
      ],
      "keywords": [
        "spawn",
        "match",
        "set",
        "return",
        "node",
        "constraint",
        "required",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "statements/tick.md",
      "title": "Tick",
      "category": "statements",
      "summary": "TICK advances the logical time counter and triggers the tick processing cycle. This is the fundamental mechanism for explicit time control in MEW, enabling deterministic simulations, turn-based systems, and controlled rule execution.",
      "headings": [
        "Spec: TICK",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Tick Processing Cycle",
        "Behavior by Statement Form",
        "Tick Amount Semantics"
      ],
      "keywords": [
        "tick",
        "match",
        "spawn",
        "link",
        "set",
        "return",
        "where",
        "node",
        "constraint",
        "rollback"
      ]
    },
    {
      "file": "statements/transactions.md",
      "title": "Transactions",
      "category": "statements",
      "summary": "Transaction statements group multiple operations into an atomic unit. Either all operations succeed and are committed together, or all fail and the graph remains unchanged. Transactions provide isolation between concurrent operations and ensure data ...",
      "headings": [
        "Spec: Transactions",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Auto-Commit Mode",
        "Explicit Transactions",
        "Isolation Levels"
      ],
      "keywords": [
        "transactions",
        "spawn",
        "link",
        "set",
        "node",
        "constraint",
        "required",
        "unique",
        "type",
        "transaction",
        "begin",
        "commit",
        "rollback"
      ]
    },
    {
      "file": "statements/trigger.md",
      "title": "Trigger",
      "category": "statements",
      "summary": "The TRIGGER statement explicitly fires a manual rule. Manual rules (declared with `[manual]` modifier) do not fire automatically during transactions; they must be triggered explicitly. This enables batch operations, maintenance tasks, and on-demand t...",
      "headings": [
        "Spec: Trigger Statement",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Execution",
        "Behavior",
        "Manual vs Auto Rules"
      ],
      "keywords": [
        "trigger",
        "match",
        "kill",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "optional",
        "type",
        "transaction"
      ]
    },
    {
      "file": "statements/unlink.md",
      "title": "Unlink",
      "category": "statements",
      "summary": "UNLINK removes an edge from the graph. It supports multiple identification methods (by edge ID, by endpoints, by pattern, or by match), handles higher-order edge cascade automatically, and can operate on single or bulk edges.",
      "headings": [
        "Spec: UNLINK",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Edge Identification",
        "Higher-Order Edge Cascade",
        "Bulk Unlink"
      ],
      "keywords": [
        "unlink",
        "match",
        "link",
        "return",
        "where",
        "node",
        "edge",
        "unique",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "statements/versioning.md",
      "title": "Versioning",
      "category": "statements",
      "summary": "Versioning provides time-travel queries, snapshots, branching, and merging. Enables auditing, experimentation, and recovery without external backup systems.",
      "headings": [
        "Spec: Versioning",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Snapshots",
        "Version References",
        "Checkout"
      ],
      "keywords": [
        "versioning",
        "match",
        "spawn",
        "kill",
        "link",
        "unlink",
        "set",
        "walk",
        "return",
        "where",
        "node",
        "edge",
        "type",
        "ontology",
        "transaction",
        "begin",
        "commit"
      ]
    },
    {
      "file": "statements/walk.md",
      "title": "Walk",
      "category": "statements",
      "summary": "The WALK statement traverses graph paths with fine-grained control: direction, depth limits, filtering, and path collection. While MATCH finds patterns, WALK explores connectivity.",
      "headings": [
        "Spec: Walk Statement",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Starting Point",
        "Edge Direction",
        "Multiple Edge Types"
      ],
      "keywords": [
        "walk",
        "match",
        "link",
        "return",
        "where",
        "node",
        "edge",
        "required",
        "type",
        "ontology"
      ]
    },
    {
      "file": "statements/watch.md",
      "title": "Watch",
      "category": "statements",
      "summary": "WATCH creates a persistent query that pushes matching changes to clients. It supports two modes: watch (non-destructive observation) and consume (destructive receipt with acknowledgment). This unified primitive handles both real-time subscriptions an...",
      "headings": [
        "Spec: WATCH",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Watch Lifecycle",
        "Event Types",
        "Mode Comparison"
      ],
      "keywords": [
        "watch",
        "match",
        "spawn",
        "link",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "type",
        "ontology",
        "transaction",
        "commit"
      ]
    },
    {
      "file": "statements/watch_management.md",
      "title": "Watch-Management",
      "category": "statements",
      "summary": "Watch management statements control the lifecycle of active watches. PAUSE temporarily stops event delivery, RESUME restarts it, CANCEL permanently removes the watch, and ALTER modifies watch options at runtime. These statements operate on watch hand...",
      "headings": [
        "Spec: Watch Management",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Watch Handle",
        "PAUSE Statement",
        "RESUME Statement"
      ],
      "keywords": [
        "watch-management",
        "match",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "type",
        "transaction",
        "commit"
      ]
    },
    {
      "file": "types/any_type.md",
      "title": "Any Type",
      "category": "types",
      "summary": "The `any` type matches any node type, enabling polymorphic edge signatures where an edge can connect to nodes of different types without union enumeration.",
      "headings": [
        "Feature: Any Type",
        "1. Overview",
        "2. Syntax",
        "2.1 Grammar Additions",
        "2.2 Keywords Added",
        "2.3 Examples",
        "3. Semantics",
        "3.1 Subtyping",
        "3.2 Usage Restrictions",
        "3.3 Pattern Matching"
      ],
      "keywords": [
        "type",
        "match",
        "link",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "union",
        "ontology"
      ]
    },
    {
      "file": "types/duration_type.md",
      "title": "Duration Type",
      "category": "types",
      "summary": "The `Duration` type represents time spans in milliseconds. It enables type-safe arithmetic with timestamps: adding a duration to a timestamp yields a timestamp, subtracting two timestamps yields a duration.",
      "headings": [
        "Spec: Duration Type",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Representation",
        "Operations",
        "Built-in Functions"
      ],
      "keywords": [
        "duration",
        "type",
        "set",
        "where",
        "node",
        "constraint",
        "required"
      ]
    },
    {
      "file": "types/edge_references.md",
      "title": "Edge References",
      "category": "types",
      "summary": "Edge reference types (`edge<T>`) allow edges to target other edges instead of nodes, enabling higher-order relationships like confidence scores, provenance tracking, and temporal validity on relationships.",
      "headings": [
        "Feature: Edge References",
        "1. Overview",
        "2. Syntax",
        "2.1 Grammar Additions",
        "2.2 Keywords Added",
        "2.3 Examples",
        "3. Semantics",
        "3.1 Edge Reference Types",
        "3.2 Type Checking",
        "3.3 Creating Higher-Order Edges"
      ],
      "keywords": [
        "edge",
        "references",
        "match",
        "link",
        "unlink",
        "return",
        "where",
        "node",
        "constraint",
        "required",
        "type",
        "ontology"
      ]
    },
    {
      "file": "types/optional_type.md",
      "title": "Optional Type",
      "category": "types",
      "summary": "The optional type (`T?`) enables nullable semantics for any base type, allowing attributes and expressions to hold either a value of type T or null. Optional types are essential for representing missing, unknown, or inapplicable data in graph schemas...",
      "headings": [
        "Spec: Optional Type",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Nullability Rules",
        "Null Propagation",
        "Null Comparison"
      ],
      "keywords": [
        "optional",
        "type",
        "match",
        "spawn",
        "link",
        "unlink",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "unique",
        "union"
      ]
    },
    {
      "file": "types/union_type.md",
      "title": "Union Type",
      "category": "types",
      "summary": "The union type (`T | U`) enables polymorphic typing by allowing a value to be one of several possible types. Union types are essential for expressing heterogeneous relationships in graph schemas, such as edges that can connect to multiple node types,...",
      "headings": [
        "Spec: Union Type",
        "Overview",
        "Syntax",
        "Grammar",
        "Keywords",
        "Examples",
        "Semantics",
        "Union Formation Rules",
        "Precedence with Optional",
        "Type Compatibility (Subtyping)"
      ],
      "keywords": [
        "union",
        "type",
        "match",
        "spawn",
        "link",
        "set",
        "return",
        "where",
        "node",
        "edge",
        "constraint",
        "required",
        "optional"
      ]
    }
  ],
  "categories": [
    "core",
    "declarations",
    "expressions",
    "literals",
    "modifiers",
    "patterns",
    "root",
    "statements",
    "types"
  ],
  "lastUpdated": "2026-01-18T20:23:29.633Z"
}