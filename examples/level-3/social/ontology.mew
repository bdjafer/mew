-- ===========================================================================
-- ONTOLOGY: Social Network
-- FOCUS: Symmetric relationships, higher-order edges, social graph patterns
-- FEATURES: modifiers/edge_symmetry.md, types/edge_references.md,
--           patterns/transitive_patterns.md
-- ===========================================================================

-- ---------------------------------------------------------------------------
-- Type Aliases
-- ---------------------------------------------------------------------------

type Username = String [match: "^[a-z][a-z0-9_]{2,29}$", unique]
type DisplayName = String [length: 1..100]
type ReactionType = String [in: ["like", "love", "laugh", "wow", "sad", "angry"]]
type TrustLevel = Float [>= 0.0, <= 1.0]
type Visibility = String [in: ["public", "friends", "private"]]
type ContentType = String [in: ["post", "comment", "share"]]

-- ---------------------------------------------------------------------------
-- Nodes
-- ---------------------------------------------------------------------------

node User {
  username: Username,
  display_name: DisplayName,
  bio: String [length: 0..500]?,
  verified: Bool = false,
  joined_at: Timestamp = now()
}

node Post {
  content: String [required, length: 1..10000],
  visibility: Visibility = "public",
  content_type: ContentType = "post",
  created_at: Timestamp = now(),
  edited_at: Timestamp?
}

node Comment {
  content: String [required, length: 1..2000],
  created_at: Timestamp = now(),
  edited_at: Timestamp?
}

node Group {
  name: String [required, unique],
  description: String?,
  visibility: Visibility = "public",
  created_at: Timestamp = now()
}

-- ---------------------------------------------------------------------------
-- Standard Edges
-- ---------------------------------------------------------------------------

-- User authored content
edge authored(author: User, post: Post) [author -> 0..*] {
  published_at: Timestamp = now()
}

-- Comment on post
edge comment_on(comment: Comment, post: Post) [comment -> 1] {
  commented_at: Timestamp = now()
}

-- Comment author
edge commented_by(comment: Comment, author: User) [comment -> 1]

-- User follows user (asymmetric)
edge follows(follower: User, followed: User) [no_self] {
  followed_at: Timestamp = now(),
  notifications_enabled: Bool = true
}

-- User blocks user (asymmetric)
edge blocks(blocker: User, blocked: User) [no_self] {
  blocked_at: Timestamp = now(),
  reason: String?
}

-- Group membership
edge member_of(user: User, group: Group) {
  role: String [in: ["member", "moderator", "admin"]] = "member",
  joined_at: Timestamp = now()
}

-- ---------------------------------------------------------------------------
-- Symmetric Edges
-- ---------------------------------------------------------------------------

-- Friendship is mutual (symmetric)
edge friend_of(a: User, b: User) [symmetric, no_self] {
  since: Timestamp = now(),
  nickname_a_for_b: String?,
  nickname_b_for_a: String?
}

-- Mutual block (both users agreed to not interact)
edge mutual_block(a: User, b: User) [symmetric, no_self] {
  since: Timestamp = now()
}

-- Collaboration between users
edge collaborates_with(a: User, b: User) [symmetric, no_self] {
  project: String?,
  since: Timestamp = now()
}

-- ---------------------------------------------------------------------------
-- Higher-Order Edges: Edges targeting edges
-- ---------------------------------------------------------------------------

-- Reaction to authored content (targets the authored edge)
edge reacted_to(user: User, target: edge<authored>) {
  reaction: ReactionType,
  reacted_at: Timestamp = now()
}

-- Trust assessment on friendship (meta-edge)
edge trust_score(assessor: User, relationship: edge<friend_of>) {
  score: TrustLevel,
  confidence: TrustLevel = 0.5,
  assessed_at: Timestamp = now()
}

-- Endorsement of a follow relationship
edge endorses_follow(endorser: User, follow_edge: edge<follows>) {
  reason: String?,
  endorsed_at: Timestamp = now()
}

-- Report on any relationship
edge reported(reporter: User, target: edge<any>) {
  reason: String [required],
  severity: String [in: ["spam", "abuse", "harassment", "other"]] = "other",
  reported_at: Timestamp = now()
}

-- ---------------------------------------------------------------------------
-- Constraints
-- ---------------------------------------------------------------------------

-- Cannot be friends with someone you block
constraint no_friend_and_block:
  u1: User, u2: User
  WHERE friend_of(u1, u2) AND blocks(u1, u2)
  => false
  [message: "Cannot be friends with someone you have blocked"]

-- Cannot follow someone who blocks you
constraint no_follow_if_blocked:
  follower: User, followed: User
  WHERE follows(follower, followed) AND blocks(followed, follower)
  => false
  [message: "Cannot follow a user who has blocked you"]

-- Private posts require friendship or ownership to view
constraint private_post_access [soft]:
  p: Post, viewer: User, author: User
  WHERE authored(author, p)
  AND p.visibility = "private"
  AND viewer != author
  AND NOT EXISTS(friend_of(viewer, author))
  => false
  [message: "Private posts are only visible to friends"]

-- Trust score must be from a mutual friend
constraint trust_requires_friendship:
  assessor: User, relationship: edge<friend_of>, u1: User, u2: User
  WHERE trust_score(assessor, relationship)
  AND friend_of(u1, u2) AS relationship
  AND assessor != u1 AND assessor != u2
  AND NOT EXISTS(friend_of(assessor, u1))
  AND NOT EXISTS(friend_of(assessor, u2))
  => false
  [message: "Can only assess trust for relationships where you know at least one party"]

-- ---------------------------------------------------------------------------
-- Rules
-- ---------------------------------------------------------------------------

-- Auto-create mutual block when both users block each other
rule create_mutual_block [priority: 80]:
  u1: User, u2: User
  WHERE blocks(u1, u2) AND blocks(u2, u1)
  AND NOT EXISTS(mutual_block(u1, u2))
  => SPAWN mb: edge { } -- Cannot actually spawn edges this way, need LINK
     -- Actually: just use LINK
  => LINK mutual_block(u1, u2)

-- Remove friendship when blocked
rule unfriend_on_block [priority: 90]:
  blocker: User, blocked: User, friendship: edge<friend_of>
  WHERE blocks(blocker, blocked)
  AND friend_of(blocker, blocked) AS friendship
  => UNLINK friendship

-- Notify when verified user follows
rule notify_verified_follow [priority: 50, manual]:
  verified_user: User, followed: User
  WHERE follows(verified_user, followed)
  AND verified_user.verified = true
  => SET followed { bio = followed.bio } -- Placeholder: would spawn notification
