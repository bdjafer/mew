-- ===========================================================================
-- ONTOLOGY: Notifications & Real-Time Messaging
-- FOCUS: Watch subscriptions, consumer patterns, delivery tracking
-- FEATURES: statements/watch.md, statements/ack.md, statements/watch_management.md
-- ===========================================================================

-- ---------------------------------------------------------------------------
-- Type Aliases
-- ---------------------------------------------------------------------------

type Priority = String [in: ["urgent", "high", "normal", "low"]]
type DeliveryStatus = String [in: ["pending", "delivered", "read", "failed", "expired"]]
type ChannelType = String [in: ["broadcast", "direct", "topic", "queue"]]
type SubscriberStatus = String [in: ["active", "paused", "suspended"]]

-- ---------------------------------------------------------------------------
-- Nodes
-- ---------------------------------------------------------------------------

node Channel {
  name: String [required, unique],
  channel_type: ChannelType = "topic",
  description: String?,
  max_subscribers: Int?,
  retention_hours: Int [>= 1] = 24,
  created_at: Timestamp = now()
}

node Message {
  content: String [required, length: 1..10000],
  priority: Priority = "normal",
  ttl_seconds: Int?,
  idempotency_key: String?,
  created_at: Timestamp = now(),
  expires_at: Timestamp?
}

node Subscriber {
  name: String [required],
  endpoint: String [required],
  status: SubscriberStatus = "active",
  max_batch_size: Int [>= 1] = 10,
  ack_timeout_seconds: Int [>= 1] = 30,
  max_retries: Int [>= 0] = 3,
  subscribed_at: Timestamp = now()
}

node Delivery {
  status: DeliveryStatus = "pending",
  attempt_count: Int [>= 0] = 0,
  delivered_at: Timestamp?,
  read_at: Timestamp?,
  failed_at: Timestamp?,
  failure_reason: String?,
  last_attempt_at: Timestamp?
}

node DeadLetter {
  original_content: String [required],
  failure_reason: String [required],
  attempt_count: Int [>= 0],
  created_at: Timestamp = now()
}

node ConsumerGroup {
  name: String [required, unique],
  partition_strategy: String [in: ["round_robin", "hash", "sticky"]] = "round_robin",
  rebalance_timeout_seconds: Int [>= 1] = 60,
  created_at: Timestamp = now()
}

-- ---------------------------------------------------------------------------
-- Edges
-- ---------------------------------------------------------------------------

-- Message belongs to channel
edge published_to(message: Message, channel: Channel) [message -> 1] {
  published_at: Timestamp = now()
}

-- Subscriber subscribes to channel
edge subscribed_to(subscriber: Subscriber, channel: Channel) {
  filter_expression: String?,
  priority_override: Priority?,
  since: Timestamp = now()
}

-- Delivery tracks message to subscriber
edge delivery_of(delivery: Delivery, message: Message) [delivery -> 1]
edge delivery_to(delivery: Delivery, subscriber: Subscriber) [delivery -> 1]

-- Dead letter references original message
edge dead_letter_of(dead_letter: DeadLetter, message: Message) [dead_letter -> 1]
edge dead_letter_for(dead_letter: DeadLetter, subscriber: Subscriber) [dead_letter -> 1]

-- Consumer group membership
edge member_of_group(subscriber: Subscriber, group: ConsumerGroup) [subscriber -> 0..1]
edge group_subscribes(group: ConsumerGroup, channel: Channel)

-- ---------------------------------------------------------------------------
-- Constraints
-- ---------------------------------------------------------------------------

-- Broadcast channels have no max_subscribers limit
constraint broadcast_unlimited [message: "Broadcast channels cannot have subscriber limits"]:
  c: Channel
  WHERE c.channel_type = "broadcast" AND c.max_subscribers IS NOT NULL
  => false

-- Queue channels must have exactly one consumer group
constraint queue_has_group [message: "Queue channels must have a consumer group"]:
  c: Channel
  WHERE c.channel_type = "queue"
  AND NOT EXISTS(g: ConsumerGroup, group_subscribes(g, c))
  => false

-- Direct channels have max 2 subscribers
constraint direct_max_two [message: "Direct channels support at most 2 subscribers"]:
  c: Channel, s1: Subscriber, s2: Subscriber, s3: Subscriber
  WHERE c.channel_type = "direct"
  AND subscribed_to(s1, c) AND subscribed_to(s2, c) AND subscribed_to(s3, c)
  AND s1 != s2 AND s2 != s3 AND s1 != s3
  => false

-- Expired messages cannot be delivered
constraint no_expired_delivery [message: "Cannot deliver expired messages"]:
  d: Delivery, m: Message
  WHERE delivery_of(d, m)
  AND m.expires_at IS NOT NULL
  AND m.expires_at < now()
  AND d.status = "pending"
  => false

-- ---------------------------------------------------------------------------
-- Rules
-- ---------------------------------------------------------------------------

-- Auto-expire pending deliveries when message expires
rule expire_deliveries [priority: 80]:
  d: Delivery, m: Message
  WHERE delivery_of(d, m)
  AND d.status = "pending"
  AND m.expires_at IS NOT NULL
  AND m.expires_at < now()
  =>
  SET d.status = "expired"

-- Create deliveries for new messages to active subscribers
rule create_deliveries [priority: 100]:
  m: Message, c: Channel, s: Subscriber
  WHERE published_to(m, c)
  AND subscribed_to(s, c)
  AND s.status = "active"
  AND NOT EXISTS(d: Delivery, delivery_of(d, m), delivery_to(d, s))
  =>
  SPAWN d: Delivery { status = "pending" }

-- Mark delivery as read when acknowledged
rule mark_read [priority: 90, manual]:
  d: Delivery
  WHERE d.status = "delivered"
  =>
  SET d.status = "read"

-- Suspend subscriber after too many failures
rule suspend_failing_subscriber [priority: 60]:
  s: Subscriber
  WHERE s.status = "active"
  =>
  SET s.status = "suspended"
